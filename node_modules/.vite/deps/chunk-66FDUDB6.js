import {
  require_buffer
} from "./chunk-NMPJAIQY.js";
import {
  __toESM
} from "./chunk-JZQ37OGZ.js";

// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var s = Object.getPrototypeOf;
var c = /* @__PURE__ */ new WeakMap();
var l = (e2) => e2 && (c.has(e2) ? c.get(e2) : s(e2) === Object.prototype || s(e2) === Array.prototype);
var g = (e2) => l(e2) && e2[t] || null;
var h = (e2, t2 = true) => {
  c.set(e2, t2);
};

// node_modules/valtio/esm/vanilla.mjs
var isObject = (x) => typeof x === "object" && x !== null;
var proxyStateMap = /* @__PURE__ */ new WeakMap();
var refSet = /* @__PURE__ */ new WeakSet();
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      h(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if ((import.meta.env && import.meta.env.MODE) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((import.meta.env && import.meta.env.MODE) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && objectIs(prevValue, value)) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = g(value) || value;
      }
      let nextValue = value;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set)
        ;
      else if (value instanceof Promise) {
        value.then((v) => {
          value.status = "fulfilled";
          value.value = v;
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@web3modal/core/dist/index.js
var import_buffer = __toESM(require_buffer());
var o = proxy({ selectedChain: void 0, chains: void 0, standaloneChains: void 0, standaloneUri: void 0, isStandalone: false, isCustomDesktop: false, isCustomMobile: false, isDataLoaded: false, isUiLoaded: false, walletConnectVersion: 1 });
var i = { state: o, subscribe(e2) {
  return subscribe(o, () => e2(o));
}, setChains(e2) {
  o.chains = e2;
}, setStandaloneChains(e2) {
  o.standaloneChains = e2;
}, setStandaloneUri(e2) {
  o.standaloneUri = e2;
}, getSelectedChain() {
  const e2 = C.client().getNetwork().chain;
  return e2 && (o.selectedChain = e2), o.selectedChain;
}, setSelectedChain(e2) {
  o.selectedChain = e2;
}, setIsStandalone(e2) {
  o.isStandalone = e2;
}, setIsCustomDesktop(e2) {
  o.isCustomDesktop = e2;
}, setIsCustomMobile(e2) {
  o.isCustomMobile = e2;
}, setIsDataLoaded(e2) {
  o.isDataLoaded = e2;
}, setIsUiLoaded(e2) {
  o.isUiLoaded = e2;
}, setWalletConnectVersion(e2) {
  o.walletConnectVersion = e2;
} };
var g2 = proxy({ initialized: false, ethereumClient: void 0 });
var C = { setEthereumClient(e2) {
  !g2.initialized && e2 && (g2.ethereumClient = e2, i.setChains(e2.chains), g2.initialized = true);
}, client() {
  if (g2.ethereumClient)
    return g2.ethereumClient;
  throw new Error("ClientCtrl has no client set");
} };
var a = proxy({ address: void 0, profileName: void 0, profileAvatar: void 0, profileLoading: false, balanceLoading: false, balance: void 0, isConnected: false });
var N = { state: a, subscribe(e2) {
  return subscribe(a, () => e2(a));
}, getAccount() {
  const e2 = C.client().getAccount();
  a.address = e2.address, a.isConnected = e2.isConnected;
}, async fetchProfile(e2, t2) {
  try {
    a.profileLoading = true;
    const s2 = t2 ?? a.address, { id: n } = C.client().getDefaultChain();
    if (s2 && n === 1) {
      const [l2, c2] = await Promise.all([C.client().fetchEnsName({ address: s2, chainId: 1 }), C.client().fetchEnsAvatar({ address: s2, chainId: 1 })]);
      c2 && await e2(c2), a.profileName = l2, a.profileAvatar = c2;
    }
  } finally {
    a.profileLoading = false;
  }
}, async fetchBalance(e2) {
  try {
    a.balanceLoading = true;
    const t2 = e2 ?? a.address;
    if (t2) {
      const s2 = await C.client().fetchBalance({ address: t2 });
      a.balance = { amount: s2.formatted, symbol: s2.symbol };
    }
  } finally {
    a.balanceLoading = false;
  }
}, setAddress(e2) {
  a.address = e2;
}, setIsConnected(e2) {
  a.isConnected = e2;
}, resetBalance() {
  a.balance = void 0;
}, resetAccount() {
  a.address = void 0, a.isConnected = false, a.profileName = void 0, a.profileAvatar = void 0, a.balance = void 0;
} };
var b = proxy({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chainImages: void 0, tokenImages: void 0, standaloneChains: void 0, enableStandaloneMode: false, enableNetworkView: false, enableAccountView: true, enableExplorer: true, defaultChain: void 0, explorerAllowList: void 0, explorerDenyList: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 });
var W = { state: b, subscribe(e2) {
  return subscribe(b, () => e2(b));
}, setConfig(e2) {
  var t2, s2, n, l2;
  if (i.setStandaloneChains(e2.standaloneChains), i.setIsStandalone(!!((t2 = e2.standaloneChains) != null && t2.length) || !!e2.enableStandaloneMode), i.setIsCustomMobile(!!((s2 = e2.mobileWallets) != null && s2.length)), i.setIsCustomDesktop(!!((n = e2.desktopWallets) != null && n.length)), i.setWalletConnectVersion((l2 = e2.walletConnectVersion) != null ? l2 : 1), e2.defaultChain)
    i.setSelectedChain(e2.defaultChain);
  else if (!i.state.isStandalone) {
    const c2 = C.client().getDefaultChain();
    i.setSelectedChain(c2);
  }
  Object.assign(b, e2);
} };
var E = "https://explorer-api.walletconnect.com";
function U(e2) {
  const t2 = Object.fromEntries(Object.entries(e2).filter(([s2, n]) => typeof n < "u" && n !== null && n !== "").map(([s2, n]) => [s2, n.toString()]));
  return new URLSearchParams(t2).toString();
}
var L = { async fetchWallets(e2, t2) {
  const s2 = U(t2), n = `${E}/v3/wallets?projectId=${e2}&${s2}`;
  return (await fetch(n)).json();
}, formatImageUrl(e2, t2) {
  return `${E}/v3/logo/lg/${t2}?projectId=${e2}`;
} };
var u = proxy({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, previewWallets: [], recomendedWallets: [] });
function I() {
  const { projectId: e2 } = W.state;
  if (!e2)
    throw new Error("projectId is required to work with explorer api");
  return e2;
}
var P = { state: u, async getPreviewWallets(e2) {
  const { listings: t2 } = await L.fetchWallets(I(), e2);
  return u.previewWallets = Object.values(t2), u.previewWallets;
}, async getRecomendedWallets() {
  const { listings: e2 } = await L.fetchWallets(I(), { page: 1, entries: 6 });
  u.recomendedWallets = Object.values(e2);
}, async getPaginatedWallets(e2) {
  const { page: t2, search: s2 } = e2, { listings: n, total: l2 } = await L.fetchWallets(I(), e2), c2 = Object.values(n), v = s2 ? "search" : "wallets";
  return u[v] = { listings: [...u[v].listings, ...c2], total: l2, page: t2 ?? 1 }, { listings: c2, total: l2 };
}, getImageUrl(e2) {
  return L.formatImageUrl(I(), e2);
}, resetSearch() {
  u.search = { listings: [], total: 0, page: 1 };
} };
var r = proxy({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 });
var w = { state: r, subscribe(e2) {
  return subscribe(r, () => e2(r));
}, push(e2, t2) {
  e2 !== r.view && (r.view = e2, t2 && (r.data = t2), r.history.push(e2));
}, replace(e2) {
  r.view = e2, r.history = [e2];
}, goBack() {
  if (r.history.length > 1) {
    r.history.pop();
    const [e2] = r.history.slice(-1);
    r.view = e2;
  }
} };
var f = proxy({ open: false });
var j = { state: f, subscribe(e2) {
  return subscribe(f, () => e2(f));
}, async open(e2) {
  return new Promise((t2) => {
    const { isStandalone: s2, isUiLoaded: n, isDataLoaded: l2 } = i.state, { isConnected: c2 } = N.state, { enableNetworkView: v } = W.state;
    if (s2 ? (i.setStandaloneUri(e2 == null ? void 0 : e2.uri), i.setStandaloneChains(e2 == null ? void 0 : e2.standaloneChains), w.replace("ConnectWallet")) : e2 != null && e2.route ? w.replace(e2.route) : c2 ? w.replace("Account") : v ? w.replace("SelectNetwork") : w.replace("ConnectWallet"), n && l2)
      f.open = true, t2();
    else {
      const O = setInterval(() => {
        i.state.isUiLoaded && i.state.isDataLoaded && (clearInterval(O), f.open = true, t2());
      }, 200);
    }
  });
}, close() {
  f.open = false;
} };
function A() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
var y = proxy({ themeMode: A() ? "dark" : "light" });
var $ = { state: y, subscribe(e2) {
  return subscribe(y, () => e2(y));
}, setThemeConfig(e2) {
  Object.assign(y, e2);
} };
var p = proxy({ open: false, message: "", variant: "success" });
var T = { state: p, subscribe(e2) {
  return subscribe(p, () => e2(p));
}, openToast(e2, t2) {
  p.open = true, p.message = e2, p.variant = t2;
}, closeToast() {
  p.open = false;
} };
var m = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", isMobile() {
  return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : false;
}, isAndroid() {
  return m.isMobile() && navigator.userAgent.toLowerCase().includes("android");
}, isEmptyObject(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.getOwnPropertyNames(e2).length === 0 && Object.getOwnPropertySymbols(e2).length === 0;
}, isHttpUrl(e2) {
  return e2.startsWith("http://") || e2.startsWith("https://");
}, formatNativeUrl(e2, t2, s2) {
  if (m.isHttpUrl(e2))
    return this.formatUniversalUrl(e2, t2, s2);
  let n = e2;
  n.includes("://") || (n = e2.replaceAll("/", "").replaceAll(":", ""), n = `${n}://`), this.setWalletConnectDeepLink(n, s2);
  const l2 = encodeURIComponent(t2);
  return `${n}wc?uri=${l2}`;
}, formatUniversalUrl(e2, t2, s2) {
  if (!m.isHttpUrl(e2))
    return this.formatNativeUrl(e2, t2, s2);
  let n = e2;
  e2.endsWith("/") && (n = e2.slice(0, -1)), this.setWalletConnectDeepLink(n, s2);
  const l2 = encodeURIComponent(t2);
  return `${n}/wc?uri=${l2}`;
}, async wait(e2) {
  return new Promise((t2) => {
    setTimeout(t2, e2);
  });
}, openHref(e2, t2) {
  window.open(e2, t2, "noreferrer noopener");
}, setWalletConnectDeepLink(e2, t2) {
  localStorage.setItem(m.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e2, name: t2 }));
}, setWalletConnectAndroidDeepLink(e2) {
  const [t2] = e2.split("?");
  localStorage.setItem(m.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t2, name: "Android" }));
}, removeWalletConnectDeepLink() {
  localStorage.removeItem(m.WALLETCONNECT_DEEPLINK_CHOICE);
}, isNull(e2) {
  return e2 === null;
} };
typeof window < "u" && (window.Buffer || (window.Buffer = import_buffer.Buffer), window.global || (window.global = window), window.process || (window.process = { env: {} }));

export {
  i,
  C,
  N,
  W,
  P,
  w,
  j,
  $,
  T,
  m
};
//# sourceMappingURL=chunk-66FDUDB6.js.map
